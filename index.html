<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>SSaved</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <script src='https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js'></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <script src="https://unpkg.com/@phosphor-icons/web"></script>

    <style>
        /* --- UTILITIES & ANIMATION --- */
        .no-scrollbar::-webkit-scrollbar { display: none; }
        .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
        
        ::view-transition-group(root) { animation-duration: 0.4s; animation-timing-function: cubic-bezier(0.16, 1, 0.3, 1); }
        
        @keyframes slideUp { from { opacity: 0; transform: translateY(30px) scale(0.96); } to { opacity: 1; transform: translateY(0) scale(1); } }
        .animate-restore { animation: slideUp 0.5s cubic-bezier(0.16, 1, 0.3, 1) forwards; opacity: 0; }

        /* --- UI COMPONENTS --- */
        .tooltip-arrow::after {
            content: " "; position: absolute; top: 100%; left: 50%; margin-left: -6px;
            border: 6px solid transparent; border-top-color: #f8fafc; filter: drop-shadow(0 1px 1px rgb(0 0 0 / 0.05));
        }
        .tooltip-container { transition: all 0.2s cubic-bezier(0.16, 1, 0.3, 1); opacity: 0; pointer-events: none; transform: translateY(8px) scale(0.95); }
        .tooltip-container.active { opacity: 1; pointer-events: auto; transform: translateY(0) scale(1); }

        #undoBtn { transition: all 0.4s cubic-bezier(0.16, 1, 0.3, 1); }
        #undoBtn.hidden-btn { opacity: 0; transform: translateX(-10px); pointer-events: none; width: 0; padding: 0; margin: 0; border: 0; }

        /* --- DRAG & SLIDER --- */
        body.global-dragging, body.global-dragging * { cursor: grabbing !important; }
        .is-dragging { opacity: 0.3; filter: grayscale(100%); }
        .card-shift-forward { transform: translateX(-30px); transition: transform 0.3s ease; }
        .card-shift-backward { transform: translateX(30px); transition: transform 0.3s ease; }

        input[type=range] { -webkit-appearance: none; width: 100%; background: transparent; }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; height: 14px; width: 14px; border-radius: 50%; background: white;
            border: 1px solid #cbd5e1; cursor: pointer; margin-top: -5px; box-shadow: 0 1px 2px rgba(0,0,0,0.1);
        }
        input[type=range]::-webkit-slider-runnable-track { width: 100%; height: 4px; cursor: pointer; background: #e2e8f0; border-radius: 2px; }
    </style>
</head>
<body class="bg-slate-50 text-slate-900 font-sans antialiased selection:bg-slate-200 selection:text-slate-900 min-h-screen">

    <header class="bg-white/80 backdrop-blur-md border-b border-slate-200 px-4 md:px-6 py-3 md:py-4 sticky top-0 z-40">
        <div class="flex flex-col md:flex-row md:items-center md:justify-between gap-3 md:gap-0 max-w-[1390px] mx-auto">
            <div class="flex items-center justify-between w-full md:w-auto">
                <div class="flex items-center gap-3">
                    <h1 class="text-xl font-bold tracking-tight text-slate-900">SSaved</h1>
                    <span id="saveIndicator" class="text-[10px] font-bold uppercase tracking-wider text-slate-300 opacity-0 transition-opacity flex items-center gap-1">Saved</span>
                </div>
                <button onclick="triggerUpload()" class="md:hidden flex items-center gap-2 px-3 py-1.5 text-sm font-medium text-white bg-slate-900 active:bg-black rounded-md shadow-sm transition-all"><i class="ph-bold ph-plus"></i> Add New</button>
            </div>
            
            <div class="flex items-center gap-2 md:gap-3 overflow-x-auto no-scrollbar w-full md:w-auto pb-1 md:pb-0">
                <button id="undoBtn" onclick="triggerUndo()" class="hidden-btn flex items-center gap-2 px-3 py-1.5 bg-rose-50 hover:bg-rose-100 text-rose-600 border border-rose-100 rounded-md text-sm font-medium transition-colors shadow-sm overflow-hidden whitespace-nowrap shrink-0">
                    <i class="ph-bold ph-arrow-u-up-left"></i> <span id="undoText">Undo</span>
                </button>

                <div class="md:hidden flex items-center bg-slate-100/80 p-1 rounded-lg border border-slate-200/50 shrink-0">
                    <button onclick="setMobileCols(1)" id="col-btn-1" class="w-8 h-8 flex center rounded-md text-slate-500 transition-all"><i class="ph-bold ph-rectangle"></i></button>
                    <button onclick="setMobileCols(2)" id="col-btn-2" class="w-8 h-8 flex center rounded-md text-slate-500 transition-all"><i class="ph-bold ph-columns"></i></button>
                    <button onclick="setMobileCols(3)" id="col-btn-3" class="w-8 h-8 flex center rounded-md text-slate-500 transition-all"><i class="ph-bold ph-layout"></i></button>
                </div>

                <div class="hidden md:flex items-center gap-2 bg-slate-100/50 px-3 py-1.5 rounded-lg border border-slate-200/50 shrink-0">
                    <i class="ph ph-corners-in text-slate-400 text-sm"></i>
                    <input type="range" min="600" max="2400" value="1390" class="w-20 md:w-24 accent-slate-900" id="widthSlider" oninput="updateWidth(this.value)">
                    <i class="ph ph-corners-out text-slate-400 text-sm"></i>
                </div>

                <div class="flex items-center gap-1 bg-slate-100/50 p-1 rounded-lg border border-slate-200/50 shrink-0">
                    <button onclick="triggerImport()" class="w-8 h-8 flex items-center justify-center text-slate-500 hover:text-slate-900 hover:bg-white rounded-md transition-all" title="Import"><i class="ph ph-upload-simple text-lg"></i></button>
                    <input type="file" id="importInput" accept=".zip" class="hidden" onchange="handleImport(this.files)">
                    <button onclick="exportData()" class="w-8 h-8 flex items-center justify-center text-slate-500 hover:text-slate-900 hover:bg-white rounded-md transition-all" title="Export"><i class="ph ph-download-simple text-lg"></i></button>
                    <div class="hidden md:block w-px h-4 bg-slate-300 mx-1"></div>
                    <button onclick="triggerUpload()" class="hidden md:flex items-center gap-2 px-3 py-1.5 text-sm font-medium text-white bg-slate-900 hover:bg-black rounded-md shadow-sm transition-all hover:scale-[1.02] active:scale-[0.98]"><i class="ph-bold ph-plus"></i> <span>Add New</span></button>
                    <input type="file" id="fileInput" multiple accept="image/*" class="hidden" onchange="handleFiles(this.files)">
                </div>
            </div>
        </div>
    </header>

    <main id="mainContainer" class="p-4 md:p-6 relative mx-auto min-h-screen transition-[max-width] duration-200 ease-out" style="max-width: 1390px;">
        <div id="emptyState" class="hidden min-h-[70vh] flex flex-col items-center justify-center text-slate-400">
            <div class="w-16 h-16 bg-slate-100 rounded-2xl flex items-center justify-center mb-4 text-slate-300"><i class="ph-fill ph-images text-3xl"></i></div>
            <p class="text-base font-medium text-slate-500">No screenshots yet</p>
            <p class="text-sm text-slate-400 mt-1">Tap "Add New" to start</p>
        </div>
        <div id="gridContainer" class="grid md:grid-cols-2 lg:grid-cols-3 gap-4 md:gap-6 pb-20 transition-all duration-300"></div>
    </main>

    <div id="statusBar" class="fixed bottom-6 left-1/2 -translate-x-1/2 bg-slate-900/90 backdrop-blur text-white px-4 py-2 rounded-full shadow-xl flex items-center gap-3 hidden transition-all z-50">
        <div class="w-3 h-3 border-2 border-white/30 border-t-white rounded-full animate-spin"></div>
        <span id="statusText" class="text-xs font-medium">Processing...</span>
    </div>
    
    <div id="dragOverlay" class="fixed inset-0 bg-slate-900/10 backdrop-blur-sm z-50 pointer-events-none opacity-0 flex items-center justify-center transition-opacity duration-200">
        <div class="bg-white px-8 py-6 rounded-2xl shadow-2xl flex flex-col items-center gap-3 transform scale-100">
            <div class="p-4 bg-blue-50 text-blue-600 rounded-full"><i class="ph-fill ph-upload-simple text-3xl"></i></div>
            <p class="text-lg font-semibold text-slate-700">Drop images to import</p>
        </div>
    </div>

    <script>
        let appData = { cards: [] }, deletedCardsStack = [], undoTimeout = null, dragSrcId = null, db;
        const DB_NAME = "SSavedDB", STORE_NAME = "cards";

        // --- INIT ---
        window.addEventListener('DOMContentLoaded', async () => {
            await initDB();
            loadCardsFromDB();
            setupGlobalDrag();
            
            // Restore Layout Prefs
            const w = localStorage.getItem('ssaved_width');
            if (w) { document.getElementById('widthSlider').value = w; updateWidth(w); }
            setMobileCols(localStorage.getItem('ssaved_cols') || 1);
        });

        // --- DB ---
        function initDB() {
            return new Promise((resolve, reject) => {
                const req = indexedDB.open(DB_NAME, 1);
                req.onupgradeneeded = (e) => { 
                    const db = e.target.result; 
                    if (!db.objectStoreNames.contains(STORE_NAME)) db.createObjectStore(STORE_NAME, { keyPath: "id" }); 
                };
                req.onsuccess = (e) => { db = e.target.result; resolve(db); };
                req.onerror = (e) => reject("DB Error");
            });
        }
        function saveCardToDB(card) {
            if (!db) return;
            const c = { ...card }; delete c.imageUrl; 
            const tx = db.transaction(STORE_NAME, "readwrite");
            tx.objectStore(STORE_NAME).put(c);
            document.getElementById('saveIndicator').classList.remove('opacity-0');
            setTimeout(() => document.getElementById('saveIndicator').classList.add('opacity-0'), 2000);
        }
        function loadCardsFromDB() {
            if (!db) return;
            const tx = db.transaction(STORE_NAME, "readonly");
            tx.objectStore(STORE_NAME).getAll().onsuccess = (e) => {
                const raw = e.target.result.map(c => ({...c, imageUrl: URL.createObjectURL(c.file)}));
                // Self-healing order index
                let fix = false; raw.forEach((c, i) => { if(c.order === undefined) { c.order = i; fix = true; }});
                appData.cards = raw.sort((a, b) => a.order - b.order);
                if(fix) reindexCards();
                render(); 
            };
        }
        function reindexCards() { appData.cards.forEach((c, i) => { c.order = i; saveCardToDB(c); }); }

        // --- RENDER ---
        function render(restoreId = null) {
            const container = document.getElementById('gridContainer');
            const empty = document.getElementById('emptyState');
            const rIds = Array.isArray(restoreId) ? restoreId : (restoreId ? [restoreId] : []);

            if (!appData.cards.length) { empty.classList.remove('hidden'); container.innerHTML = ''; return; }
            empty.classList.add('hidden');

            container.innerHTML = appData.cards.map(c => {
                const isRestored = c.isRestored ? "border-rose-200 shadow-xl shadow-rose-400/40" : "border-slate-200 shadow-sm";
                const restoreAttr = c.isRestored ? `onmouseenter="clearRestoreStatus(${c.id})"` : "";
                const pulse = c.isScanning ? "animate-pulse" : "";
                const enter = rIds.includes(c.id) ? 'animate-restore' : '';
                
                // Tooltip Logic
                const hasSuggestions = !c.isScanning && c.suggestions.length !== 1;
                let tooltip = "";
                if (hasSuggestions) {
                    const content = c.suggestions.length === 0 
                        ? `<div class="bg-slate-50/90 backdrop-blur-md rounded-xl p-3 shadow-xl border border-slate-200 text-xs text-slate-500 text-center">No valid text found.</div>`
                        : `<div class="bg-slate-50/90 backdrop-blur-md rounded-xl p-3 shadow-xl border border-slate-200 ring-1 ring-black/5"><div class="flex flex-wrap gap-2">${c.suggestions.map(w => `<button onmousedown="event.preventDefault(); applySuggestion(${c.id}, '${cleanString(w)}')" class="px-2.5 py-1.5 bg-white hover:bg-slate-100 border border-slate-200 text-slate-600 text-xs font-medium rounded-lg shadow-sm transition-all">${w}</button>`).join('')}</div></div>`;
                    tooltip = `<div id="tooltip-${c.id}" class="tooltip-container absolute bottom-full left-0 w-full mb-3 z-50"><div class="tooltip-arrow relative">${content}</div></div>`;
                }

                return `
                <div id="card-${c.id}" draggable="true" ondragstart="handleDragStart(event, ${c.id})" ondragover="handleDragOver(event, ${c.id})" ondrop="handleDropSort(event, ${c.id})" ondragend="handleDragEnd(event)" ${restoreAttr} style="view-transition-name: card-${c.id}" class="bg-white rounded-xl border overflow-hidden group hover:shadow-md transition-all duration-300 flex flex-col ${isRestored} ${pulse} ${enter}">
                    <div class="aspect-[9/16] bg-slate-100 relative overflow-hidden group/image shrink-0 cursor-pointer active:cursor-move" onclick="handleImageClick(event, ${c.id})">
                        <img src="${c.imageUrl}" class="w-full h-full object-cover object-top pointer-events-none" loading="lazy">
                        <div class="absolute top-4 right-4 z-20 opacity-0 group-hover/image:opacity-100 transition-opacity">
                            <button onclick="event.stopPropagation(); deleteCard(${c.id})" class="p-2 bg-white/60 hover:bg-red-50/90 backdrop-blur-md border border-white/40 text-slate-700 hover:text-red-600 rounded-md shadow-sm transition-all"><i class="ph-bold ph-x text-lg"></i></button>
                        </div>
                    </div>
                    <div class="p-4 flex flex-col gap-3 flex-1">
                        <div class="relative username-wrapper z-10">
                            ${tooltip}
                            <div class="relative group/input">
                                <div class="absolute inset-y-0 left-0 pl-1 flex items-center pointer-events-none"><span class="text-slate-400 font-medium">@</span></div>
                                <input type="text" value="${c.username}" ${hasSuggestions ? `onfocus="triggerTooltip(${c.id})"` : ''} oninput="updateCard(${c.id}, 'username', this.value)" class="w-full pl-6 pr-8 py-1 bg-transparent border-0 border-b border-slate-200 focus:border-slate-400 outline-none text-sm font-semibold text-slate-400 group-hover/input:text-slate-800 focus:text-slate-800 transition-colors" placeholder="Username">
                                ${hasSuggestions ? `<div class="absolute inset-y-0 right-0 pr-3 flex items-center pointer-events-none"><i class="ph-fill ph-magic-wand text-slate-300"></i></div>` : ''}
                            </div>
                        </div>
                        <textarea onchange="updateCard(${c.id}, 'notes', this.value)" class="w-full text-xs text-slate-500 bg-transparent border-0 border-b border-slate-100 focus:border-slate-300 outline-none resize-none p-1" rows="1" placeholder="Add notes...">${c.notes}</textarea>
                        <a href="${c.link}" target="_blank" class="mt-auto w-fit group/btn flex items-center justify-center gap-2 px-4 py-2 bg-slate-50 hover:bg-slate-100 text-slate-600 hover:text-slate-900 border border-slate-200 text-xs font-medium rounded-full transition-colors">Visit Profile <i class="ph-bold ph-arrow-up-right"></i></a>
                    </div>
                </div>`;
            }).join('');
        }

        // --- DRAG & DROP ---
        function handleDragStart(e, id) {
            dragSrcId = id; e.dataTransfer.effectAllowed = 'move'; e.dataTransfer.setData('text/plain', id);
            document.body.classList.add('global-dragging');
            setTimeout(() => document.getElementById(`card-${id}`)?.classList.add('is-dragging'), 0);
        }
        function handleDragOver(e, id) {
            if (e.preventDefault) e.preventDefault(); e.dataTransfer.dropEffect = 'move';
            if (!dragSrcId || dragSrcId === id) return false;
            
            const from = appData.cards.findIndex(c => c.id === dragSrcId), to = appData.cards.findIndex(c => c.id === id);
            if (from === -1 || to === -1) return;

            document.querySelectorAll('.card-shift-forward, .card-shift-backward').forEach(el => { el.classList.remove('card-shift-forward', 'card-shift-backward'); el.style.transform = ''; });
            const start = Math.min(from, to), end = Math.max(from, to);
            for (let i = start; i <= end; i++) {
                if (i === from) continue;
                const el = document.getElementById(`card-${appData.cards[i].id}`);
                if (el) el.classList.add(from < to ? 'card-shift-forward' : 'card-shift-backward');
            }
        }
        function handleDropSort(e, targetId) {
            e.stopPropagation(); e.preventDefault();
            if (!dragSrcId || dragSrcId === targetId) return;
            const from = appData.cards.findIndex(c => c.id === dragSrcId), to = appData.cards.findIndex(c => c.id === targetId);
            if (from > -1 && to > -1) {
                appData.cards.splice(to, 0, appData.cards.splice(from, 1)[0]);
                reindexCards();
                document.startViewTransition ? document.startViewTransition(() => render()) : render();
            }
        }
        function handleDragEnd() {
            document.body.classList.remove('global-dragging');
            document.querySelectorAll('.is-dragging, .card-shift-forward, .card-shift-backward').forEach(el => {
                el.classList.remove('is-dragging', 'card-shift-forward', 'card-shift-backward'); el.style.transform = '';
            });
            dragSrcId = null;
        }

        // --- FILE & OCR (FIXED) ---
        function simpleCrop(url) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => {
                    const c = document.createElement('canvas'), h = img.height * 0.2;
                    c.width = img.width; c.height = h;
                    c.getContext('2d').drawImage(img, 0, 0, img.width, h, 0, 0, img.width, h);
                    c.toBlob(resolve);
                };
                img.onerror = reject; img.src = url;
            });
        }
        async function handleFiles(files) {
            if (!files.length) return;
            showStatus(true, `Processing ${files.length}...`);
            const newCards = Array.from(files).map((f, i) => ({ 
                id: Date.now() + i, file: f, imageUrl: URL.createObjectURL(f), 
                username: "", notes: "", link: "#", isScanning: true, suggestions: [] 
            }));
            
            // 1. Save & Render (Blocking UI avoided)
            newCards.forEach(c => saveCardToDB(c));
            appData.cards.unshift(...newCards);
            reindexCards();
            
            if (document.startViewTransition) await document.startViewTransition(() => render(newCards.map(c => c.id))).finished;
            else render(newCards.map(c => c.id));

            // 2. Pause to let UI settle, preventing "Blank Screen" bug
            await new Promise(r => setTimeout(r, 100));

            // 3. Process OCR
            for (const c of newCards) {
                try {
                    const blob = await simpleCrop(c.imageUrl);
                    const { data: { words } } = await Tesseract.recognize(blob, 'eng');
                    const banned = ['follow', 'followers', 'following', 'posts'];
                    const valid = words.map(w => w.text.trim()).filter(w => w.length > 4 && !/[:;,]/.test(w) && !banned.includes(w.toLowerCase())).sort((a,b) => b.length - a.length);
                    const best = valid[0] ? cleanString(valid[0]) : "";
                    
                    const actual = appData.cards.find(x => x.id === c.id);
                    if (actual) {
                        Object.assign(actual, { username: best, link: `https://instagram.com/${best}`, suggestions: valid, isScanning: false });
                        saveCardToDB(actual); updateDOMCard(actual.id);
                    }
                } catch (e) { console.error(e); }
            }
            showStatus(false);
        }

        // --- LAYOUT ---
        function updateWidth(val) {
            const el = document.getElementById('mainContainer');
            el.style.maxWidth = val > 2350 ? '100%' : `${val}px`;
            localStorage.setItem('ssaved_width', val);
        }
        function setMobileCols(n) {
            const grid = document.getElementById('gridContainer');
            grid.classList.remove('grid-cols-1', 'grid-cols-2', 'grid-cols-3');
            grid.classList.add(`grid-cols-${n}`);
            localStorage.setItem('ssaved_cols', n);
            [1,2,3].forEach(i => {
                const b = document.getElementById(`col-btn-${i}`);
                if(b) b.className = `w-8 h-8 flex items-center justify-center rounded-md transition-all ${i==n ? 'bg-white text-slate-900 shadow-sm font-bold' : 'text-slate-500'}`;
            });
        }

        // --- UTILS ---
        function showStatus(show, txt) { 
            const el = document.getElementById('statusBar'); el.classList.toggle('hidden', !show); el.classList.toggle('flex', show);
            document.getElementById('statusText').innerText = txt;
        }
        function cleanString(s) { return s.replace(/[^a-zA-Z0-9_.]/g, '').toLowerCase(); }
        function triggerUpload() { document.getElementById('fileInput').click(); }
        function triggerImport() { document.getElementById('importInput').click(); }
        function handleImageClick(e, id) { if(!e.target.closest('button')) { const c = appData.cards.find(x => x.id === id); if(c.link !== '#') window.open(c.link, '_blank'); }}

        // Tooltip & Editing
        window.addEventListener('click', (e) => { if (!e.target.closest('.username-wrapper')) closeAllTooltips(); });
        window.addEventListener('keydown', (e) => { if (e.key === 'Escape') closeAllTooltips(); });
        function triggerTooltip(id) { closeAllTooltips(); document.getElementById(`tooltip-${id}`)?.classList.add('active'); }
        function closeAllTooltips() { document.querySelectorAll('.tooltip-container').forEach(e => e.classList.remove('active')); }
        function applySuggestion(id, w) { const c = appData.cards.find(x => x.id === id); if(c) { c.username = w; c.link = `https://instagram.com/${w}`; saveCardToDB(c); updateDOMCard(id); closeAllTooltips(); } }
        function updateCard(id, f, v) { const c = appData.cards.find(x => x.id === id); if(c) { c[f] = v; if(f==='username') c.link = `https://instagram.com/${v}`; saveCardToDB(c); } }
        function updateDOMCard(id) {
            const c = appData.cards.find(x => x.id === id), el = document.getElementById(`card-${id}`);
            if (el && c) {
                const inp = el.querySelector('input'); if(inp && document.activeElement !== inp) inp.value = c.username;
                el.querySelector('a').href = c.link;
                if(!c.isScanning) el.classList.remove('animate-pulse');
            }
        }

        // Delete / Undo
        function deleteCard(id) {
            const idx = appData.cards.findIndex(c => c.id === id);
            if(idx > -1) {
                deletedCardsStack.push(appData.cards.splice(idx, 1)[0]);
                const tx = db.transaction(STORE_NAME, "readwrite"); tx.objectStore(STORE_NAME).delete(id);
                document.startViewTransition ? document.startViewTransition(() => render()) : render();
                updateUndoUI();
            }
        }
        function triggerUndo() {
            if (!deletedCardsStack.length) return;
            const c = deletedCardsStack.pop(); c.isRestored = true;
            appData.cards.splice(Math.min(c.order, appData.cards.length), 0, c);
            reindexCards();
            document.startViewTransition ? document.startViewTransition(() => render(c.id)) : render(c.id);
            updateUndoUI();
        }
        function clearRestoreStatus(id) {
            const c = appData.cards.find(x => x.id === id);
            if (c?.isRestored) { c.isRestored = false; saveCardToDB(c); document.getElementById(`card-${id}`)?.classList.remove('border-rose-200', 'shadow-xl', 'shadow-rose-400/40'); document.getElementById(`card-${id}`)?.classList.add('border-slate-200', 'shadow-sm'); }
        }
        function updateUndoUI() {
            const btn = document.getElementById('undoBtn'), txt = document.getElementById('undoText');
            if (undoTimeout) clearTimeout(undoTimeout);
            if (deletedCardsStack.length) {
                btn.classList.remove('hidden-btn'); txt.innerText = deletedCardsStack.length > 1 ? `Undo (${deletedCardsStack.length})` : "Undo Delete";
                undoTimeout = setTimeout(() => btn.classList.add('hidden-btn'), 5000);
            } else btn.classList.add('hidden-btn');
        }

        // Global Drag Setup
        function setupGlobalDrag() {
            const ov = document.getElementById('dragOverlay'); let c = 0;
            ['dragenter','dragleave','dragover','drop'].forEach(evt => window.addEventListener(evt, e => {
                if (dragSrcId) return; // Ignore if reordering internal cards
                e.preventDefault();
                if (evt === 'dragenter' && e.dataTransfer.types.includes('Files')) { c++; ov.classList.remove('opacity-0'); }
                if (evt === 'dragleave') { c--; if(c === 0) ov.classList.add('opacity-0'); }
                if (evt === 'drop') { c = 0; ov.classList.add('opacity-0'); if(e.dataTransfer.files.length) handleFiles(e.dataTransfer.files); }
            }));
        }

        // Backup
        async function handleImport(files) {
            if (!files.length) return;
            showStatus(true, "Restoring...");
            try {
                const zip = await JSZip.loadAsync(files[0]);
                const json = JSON.parse(await zip.file("data.json").async("string"));
                const newCards = await Promise.all(json.map(async d => {
                    const blob = await zip.file("images/" + d.fileName)?.async("blob");
                    if (!blob) return null;
                    return { id: d.id, file: new File([blob], d.fileName), imageUrl: URL.createObjectURL(blob), username: d.username, notes: d.notes, link: `https://instagram.com/${d.username}`, suggestions: d.suggestions || [], isScanning: false };
                }));
                const valid = newCards.filter(c => c && !appData.cards.find(x => x.id === c.id));
                valid.forEach(c => saveCardToDB(c));
                appData.cards.unshift(...valid); reindexCards();
                document.startViewTransition ? document.startViewTransition(() => render()) : render();
            } catch(e) { alert("Import failed"); }
            showStatus(false);
        }
        async function exportData() {
            if (!appData.cards.length) return;
            showStatus(true, "Zipping...");
            const zip = new JSZip(), folder = zip.folder("images");
            zip.file("data.json", JSON.stringify(appData.cards.map(c => ({...c, fileName:`img_${c.id}.png`, file:undefined, imageUrl:undefined})), null, 2));
            appData.cards.forEach(c => folder.file(`img_${c.id}.png`, c.file));
            saveAs(await zip.generateAsync({type:"blob"}), "ssaved-backup.zip");
            showStatus(false);
        }
    </script>
</body>
</html>