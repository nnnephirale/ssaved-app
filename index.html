<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>SSaved</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <script src='https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js'></script>
    <script src="https://unpkg.com/@phosphor-icons/web"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        warm: {
                            50: '#FAFAF8',
                            100: '#F5F5F3',
                            200: '#EEEDE9',
                        }
                    }
                }
            }
        }
    </script>

    <style>
        /* --- BASE & WARM BACKGROUND --- */
        body {
            background: linear-gradient(180deg, #FAFAF8 0%, #F7F6F3 100%);
            min-height: 100vh;
        }

        /* --- FOLDER TABS --- */
        .folder-tab {
            clip-path: polygon(0 0, 85% 0, 100% 100%, 0% 100%);
            padding-left: 1.5rem;
            padding-right: 2.5rem;
        }
        .folder-drop-active .folder-tab { 
            background-color: #3b82f6 !important; 
            color: white !important; 
            transition: background-color 0.2s;
        }
        .folder-drop-active .folder-grid-area {
            background-color: rgba(59, 130, 246, 0.05);
            border-radius: 1rem;
            box-shadow: inset 0 0 0 2px rgba(59, 130, 246, 0.2);
        }

        /* --- CARD STYLING --- */
        .card {
            background: white;
            border-radius: 1.25rem;
            border: 1px solid rgba(0, 0, 0, 0.04);
            overflow: hidden;
            box-shadow: 
                0 2px 4px -1px rgba(0, 0, 0, 0.02),
                0 8px 24px -4px rgba(0, 0, 0, 0.06);
            transition: transform 0.25s cubic-bezier(0.16, 1, 0.3, 1), 
                        box-shadow 0.25s cubic-bezier(0.16, 1, 0.3, 1);
        }
        .card:hover {
            transform: translateY(-3px);
            box-shadow: 
                0 4px 8px -2px rgba(0, 0, 0, 0.03),
                0 16px 40px -8px rgba(0, 0, 0, 0.1);
        }
        .card.is-restored {
            border-color: rgba(244, 63, 94, 0.25);
            box-shadow: 
                0 4px 8px -2px rgba(244, 63, 94, 0.08),
                0 16px 48px -8px rgba(244, 63, 94, 0.2);
        }
        .card.is-dragging {
            opacity: 0.4;
            filter: grayscale(80%);
            transform: scale(0.98);
        }

        /* --- AUTO-GROW INPUTS --- */
        .auto-grow {
            field-sizing: content;
            min-height: 24px;
            resize: none;
            overflow: hidden;
        }

        /* --- UTILITIES --- */
        .no-scrollbar::-webkit-scrollbar { display: none; }
        .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
        ::view-transition-group(root) { animation-duration: 0.35s; animation-timing-function: cubic-bezier(0.16, 1, 0.3, 1); }
        
        /* --- ANIMATIONS --- */
        @keyframes slideUp { 
            from { opacity: 0; transform: translateY(20px) scale(0.96); } 
            to { opacity: 1; transform: translateY(0) scale(1); } 
        }
        @keyframes subtlePulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        .animate-restore { animation: slideUp 0.5s cubic-bezier(0.16, 1, 0.3, 1) forwards; opacity: 0; }
        .folder-enter { animation: slideUp 0.5s ease-out forwards; }
        .animate-pulse-subtle { animation: subtlePulse 2s ease-in-out infinite; }

        /* --- UI COMPONENTS --- */
        .tooltip-arrow::after {
            content: " "; position: absolute; top: 100%; left: 50%; margin-left: -6px;
            border: 6px solid transparent; border-top-color: rgba(255,255,255,0.95); filter: drop-shadow(0 1px 2px rgb(0 0 0 / 0.08));
        }
        .tooltip-container { 
            transition: all 0.25s cubic-bezier(0.16, 1, 0.3, 1); 
            opacity: 0; 
            pointer-events: none; 
            transform: translateY(8px) scale(0.95); 
        }
        .tooltip-container.active { opacity: 1; pointer-events: auto; transform: translateY(0) scale(1); }

        /* --- UNDO BUTTON --- */
        #undoBtn.hidden-btn { opacity: 0; transform: translateX(-10px); pointer-events: none; width: 0; padding: 0; margin: 0; border: 0; }
        #undoBtn { 
            transition: all 0.4s cubic-bezier(0.16, 1, 0.3, 1); 
            box-shadow: 0 2px 8px -2px rgba(244, 63, 94, 0.3);
        }

        /* --- DRAG & DROP --- */
        body.global-dragging, body.global-dragging * { cursor: grabbing !important; }
        .card-shift-forward { transform: translateX(-24px); transition: transform 0.3s cubic-bezier(0.16, 1, 0.3, 1); }
        .card-shift-backward { transform: translateX(24px); transition: transform 0.3s cubic-bezier(0.16, 1, 0.3, 1); }

        /* Drag image styling - ensure rounded corners are preserved */
        .drag-ghost {
            position: absolute;
            top: -10000px;
            left: -10000px;
            border-radius: 1.25rem;
            overflow: hidden;
            pointer-events: none;
        }
        
        /* --- SLIDER STYLING --- */
        input[type=range] { -webkit-appearance: none; width: 100%; background: transparent; }
        input[type=range]::-webkit-slider-thumb { 
            -webkit-appearance: none; 
            height: 16px; 
            width: 16px; 
            border-radius: 50%; 
            background: white; 
            border: 1px solid rgba(0,0,0,0.1); 
            cursor: pointer; 
            margin-top: -6px; 
            box-shadow: 0 2px 6px rgba(0,0,0,0.1); 
            transition: transform 0.15s ease, box-shadow 0.15s ease;
        }
        input[type=range]::-webkit-slider-thumb:hover {
            transform: scale(1.1);
            box-shadow: 0 3px 10px rgba(0,0,0,0.15);
        }
        input[type=range]::-webkit-slider-runnable-track { 
            width: 100%; 
            height: 4px; 
            cursor: pointer; 
            background: rgba(0,0,0,0.08); 
            border-radius: 2px; 
        }

        /* --- HEADER --- */
        .header-glass {
            background: rgba(255, 255, 255, 0.7);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-bottom: 1px solid rgba(0, 0, 0, 0.06);
        }

        /* --- BUTTONS --- */
        .btn-primary {
            background: #1a1a1a;
            color: white;
            border-radius: 0.625rem;
            font-weight: 500;
            transition: all 0.2s cubic-bezier(0.16, 1, 0.3, 1);
            box-shadow: 0 2px 8px -2px rgba(0,0,0,0.2);
        }
        .btn-primary:hover {
            background: #000;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px -2px rgba(0,0,0,0.25);
        }
        .btn-primary:active {
            transform: translateY(0) scale(0.98);
        }

        .btn-secondary {
            background: rgba(0,0,0,0.04);
            color: #525252;
            border-radius: 0.625rem;
            font-weight: 600;
            transition: all 0.2s ease;
        }
        .btn-secondary:hover {
            background: rgba(0,0,0,0.08);
            color: #1a1a1a;
        }

        /* --- EXTERNAL LINK BUTTON --- */
        .external-link-btn {
            position: absolute;
            top: 0.75rem;
            left: 0.75rem;
            opacity: 0;
            transform: scale(0.9);
            transition: all 0.2s cubic-bezier(0.16, 1, 0.3, 1);
        }
        .group\/image:hover .external-link-btn {
            opacity: 1;
            transform: scale(1);
        }

        /* --- DELETE BUTTON --- */
        .delete-btn {
            position: absolute;
            top: 0.75rem;
            right: 0.75rem;
            opacity: 0;
            transform: scale(0.9);
            transition: all 0.2s cubic-bezier(0.16, 1, 0.3, 1);
        }
        .group\/image:hover .delete-btn {
            opacity: 1;
            transform: scale(1);
        }

        /* --- FOCUS STATES --- */
        textarea:focus {
            outline: none;
            border-color: rgba(0,0,0,0.2) !important;
        }
        .focus-ring:focus {
            box-shadow: 0 0 0 3px rgba(244, 63, 94, 0.12);
        }

        /* --- COLLAPSIBLE NOTES (Mobile Only) --- */
        @media (max-width: 767px) {
            .notes-wrapper {
                position: relative;
            }
            .notes-wrapper .notes-toggle {
                display: none;
            }
            .notes-wrapper .notes-fade {
                display: none;
            }
            .notes-wrapper.is-collapsible .notes-textarea {
                max-height: 4.5em;
                overflow: hidden;
                transition: max-height 0.35s cubic-bezier(0.16, 1, 0.3, 1);
            }
            .notes-wrapper.is-collapsible.is-expanded .notes-textarea {
                max-height: 500px;
            }
            .notes-wrapper.is-collapsible .notes-fade {
                display: block;
                position: absolute;
                bottom: 1.5rem;
                left: 0;
                right: 0;
                height: 1.5em;
                background: linear-gradient(to bottom, transparent, white);
                pointer-events: none;
                opacity: 1;
                transition: opacity 0.2s ease;
            }
            .notes-wrapper.is-collapsible.is-expanded .notes-fade {
                opacity: 0;
            }
            .notes-wrapper.is-collapsible .notes-toggle {
                display: flex;
                align-items: center;
                justify-content: center;
                width: 100%;
                padding: 0.25rem 0;
                color: #a3a3a3;
                transition: color 0.15s ease;
            }
            .notes-toggle:hover,
            .notes-toggle:active {
                color: #525252;
            }
            .notes-toggle i {
                font-size: 0.875rem;
                transition: transform 0.25s cubic-bezier(0.16, 1, 0.3, 1);
            }
            .notes-wrapper.is-expanded .notes-toggle i {
                transform: rotate(180deg);
            }
        }
        @media (min-width: 768px) {
            .notes-toggle {
                display: none !important;
            }
            .notes-fade {
                display: none !important;
            }
        }

        /* --- DROP OVERLAY --- */
        .drop-overlay-card {
            background: rgba(255,255,255,0.9);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            border-radius: 1.5rem;
            box-shadow: 0 24px 80px -12px rgba(0,0,0,0.15);
        }

        /* --- IMAGE HOVER SCALE (Desktop only, non-touch) --- */
        @media (hover: hover) and (pointer: fine) {
            .group\/image:hover .img-hover-scale {
                transform: scale(1.02);
            }
        }

        /* --- SHARE URL MODAL --- */
        .modal-backdrop {
            background: rgba(0,0,0,0.4);
            backdrop-filter: blur(4px);
        }
        .modal-content {
            background: white;
            border-radius: 1.25rem;
            box-shadow: 0 24px 80px -12px rgba(0,0,0,0.25);
        }

        /* --- LOADING STATE --- */
        .loading-screen {
            position: fixed;
            inset: 0;
            background: linear-gradient(180deg, #FAFAF8 0%, #F7F6F3 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
            transition: opacity 0.3s ease;
        }
        .loading-screen.hidden {
            opacity: 0;
            pointer-events: none;
        }

        /* --- DROPDOWN MENU --- */
        #addMenuMobile, #addMenuDesktop {
            animation: dropdownFadeIn 0.15s ease-out;
        }
        @keyframes dropdownFadeIn {
            from {
                opacity: 0;
                transform: translateY(-8px) scale(0.96);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }
    </style>
</head>
<body class="text-neutral-900 font-sans antialiased selection:bg-rose-100 selection:text-rose-900 min-h-screen">

    <!-- Loading Screen -->
    <div id="loadingScreen" class="loading-screen">
        <div class="flex flex-col items-center gap-4">
            <div class="w-8 h-8 border-2 border-neutral-200 border-t-neutral-600 rounded-full animate-spin"></div>
            <p class="text-sm text-neutral-500" id="loadingText">Loading your collection...</p>
        </div>
    </div>

    <header id="mainHeader" class="header-glass px-4 md:px-6 py-3 fixed top-0 w-full z-40 transition-transform duration-300 ease-in-out">
        <div class="flex flex-col md:flex-row md:items-center md:justify-between gap-3 max-w-[1390px] mx-auto">
            <!-- Mobile Header Row -->
            <div class="flex items-center justify-between w-full md:w-auto">
                <div class="flex items-center gap-2">
                    <h1 class="text-lg font-semibold tracking-tight text-neutral-800">SSaved</h1>
                    <!-- Mobile: Link icon next to title -->
                    <button onclick="showShareModal()" class="md:hidden w-8 h-8 flex items-center justify-center text-neutral-400 hover:text-neutral-900 rounded-md transition-all" title="Share Link">
                        <i class="ph ph-link text-lg"></i>
                    </button>
                    <span id="saveIndicator" class="text-[10px] font-medium uppercase tracking-wider text-neutral-300 opacity-0 transition-opacity">Saved</span>
                </div>
                <!-- Mobile: Add button with dropdown -->
                <div class="md:hidden relative">
                    <button onclick="toggleAddMenu('mobile')" class="btn-primary flex items-center gap-2 px-3 py-1.5 text-sm">
                        <i class="ph-bold ph-plus"></i> Add
                    </button>
                    <div id="addMenuMobile" class="absolute right-0 top-full mt-2 w-48 bg-white rounded-xl shadow-xl border border-neutral-100 py-1 hidden z-50">
                        <button onclick="triggerUpload(); closeAddMenus()" class="w-full px-4 py-2.5 text-left text-sm text-neutral-700 hover:bg-neutral-50 flex items-center gap-3">
                            <i class="ph ph-image text-neutral-400"></i> Add Screenshot
                        </button>
                        <button onclick="createNewFolder(); closeAddMenus()" class="w-full px-4 py-2.5 text-left text-sm text-neutral-700 hover:bg-neutral-50 flex items-center gap-3">
                            <i class="ph ph-folder-plus text-neutral-400"></i> New Folder
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- Desktop & Mobile Controls Row -->
            <div class="flex items-center gap-2 md:gap-3 overflow-x-auto no-scrollbar w-full md:w-auto pb-1 md:pb-0">
                <button id="undoBtn" onclick="triggerUndo()" class="hidden-btn flex items-center gap-2 px-3 py-1.5 bg-rose-50 hover:bg-rose-100 text-rose-600 border border-rose-100 rounded-lg text-sm font-medium whitespace-nowrap shrink-0">
                    <i class="ph-bold ph-arrow-u-up-left"></i> <span id="undoText">Undo</span>
                </button>

                <!-- Mobile: Column toggle -->
                <div class="md:hidden flex bg-neutral-100/80 p-1 rounded-lg border border-neutral-200/50 shrink-0">
                    <button onclick="setMobileCols(1)" id="col-btn-1" class="w-8 h-8 flex items-center justify-center rounded-md text-neutral-400 hover:text-neutral-900 transition-all"><i class="ph-bold ph-rectangle"></i></button>
                    <button onclick="setMobileCols(2)" id="col-btn-2" class="w-8 h-8 flex items-center justify-center rounded-md text-neutral-400 hover:text-neutral-900 transition-all"><i class="ph-bold ph-columns"></i></button>
                </div>

                <!-- Desktop: Width slider -->
                <div class="hidden md:flex items-center gap-2 bg-neutral-100/50 px-3 py-1.5 rounded-lg border border-neutral-200/50 shrink-0">
                    <i class="ph ph-corners-in text-neutral-400 text-sm"></i>
                    <input type="range" min="600" max="2400" value="1390" class="w-20 md:w-24" id="widthSlider" oninput="updateWidth(this.value)">
                </div>

                <!-- Desktop: Share button (inside overflow container) -->
                <div class="hidden md:flex items-center gap-1 bg-neutral-100/50 p-1 rounded-lg border border-neutral-200/50 shrink-0">
                    <button onclick="showShareModal()" class="w-8 h-8 flex items-center justify-center text-neutral-400 hover:text-neutral-900 hover:bg-white rounded-md transition-all" title="Share Link"><i class="ph ph-link text-lg"></i></button>
                </div>
                
                <input type="file" id="fileInput" multiple accept="image/*" class="hidden" onchange="handleFiles(this.files)">
            </div>
            
            <!-- Desktop: Add button (outside overflow container so dropdown isn't clipped) -->
            <div class="hidden md:block relative shrink-0">
                <button onclick="toggleAddMenu('desktop')" class="btn-primary flex items-center gap-2 px-3 py-1.5 text-sm">
                    <i class="ph-bold ph-plus"></i> <span>Add</span>
                </button>
                <div id="addMenuDesktop" class="absolute right-0 top-full mt-2 w-52 bg-white rounded-xl shadow-xl border border-neutral-100 py-1 hidden z-50">
                    <button onclick="triggerUpload(); closeAddMenus()" class="w-full px-4 py-2.5 text-left text-sm text-neutral-700 hover:bg-neutral-50 flex items-center gap-3">
                        <i class="ph ph-image text-neutral-400"></i> Add Screenshot
                    </button>
                    <button onclick="createNewFolder(); closeAddMenus()" class="w-full px-4 py-2.5 text-left text-sm text-neutral-700 hover:bg-neutral-50 flex items-center gap-3">
                        <i class="ph ph-folder-plus text-neutral-400"></i> New Folder
                    </button>
                </div>
            </div>
        </div>
    </header>

    <main id="mainContainer" class="p-4 md:p-6 pt-36 md:pt-28 relative mx-auto min-h-screen transition-[max-width] duration-200 ease-out" style="max-width: 1390px;">
        
        <div id="emptyState" class="hidden min-h-[70vh] flex flex-col items-center justify-center text-neutral-400">
            <div class="w-20 h-20 bg-neutral-100 rounded-2xl flex items-center justify-center mb-5 text-neutral-300"><i class="ph-fill ph-images text-4xl"></i></div>
            <p class="text-base font-medium text-neutral-500">No screenshots yet</p>
            <p class="text-sm text-neutral-400 mt-1">Tap "Add" to start</p>
        </div>

        <div id="folderWrapper" class="flex flex-col gap-12 pb-32"></div>

    </main>

    <!-- Share Modal -->
    <div id="shareModal" class="fixed inset-0 z-50 hidden items-center justify-center p-4 modal-backdrop">
        <div class="modal-content w-full max-w-md p-6">
            <div class="flex items-center justify-between mb-4">
                <h2 class="text-lg font-semibold">Share Your Collection</h2>
                <button onclick="closeShareModal()" class="p-2 text-neutral-400 hover:text-neutral-900 rounded-lg transition-colors">
                    <i class="ph-bold ph-x"></i>
                </button>
            </div>
            <p class="text-sm text-neutral-500 mb-4">Anyone with this link can view and edit your collection. Bookmark it to return later.</p>
            <div class="flex gap-2">
                <input type="text" id="shareUrlInput" readonly class="flex-1 px-3 py-2 bg-neutral-50 border border-neutral-200 rounded-lg text-sm text-neutral-700 font-mono">
                <button onclick="copyShareUrl()" class="btn-primary px-4 py-2 flex items-center gap-2">
                    <i class="ph-bold ph-copy"></i> Copy
                </button>
            </div>
            <p id="copyConfirm" class="text-xs text-green-600 mt-2 opacity-0 transition-opacity">Copied to clipboard!</p>
        </div>
    </div>

    <div id="statusBar" class="fixed bottom-6 left-1/2 -translate-x-1/2 bg-neutral-900/90 backdrop-blur-md text-white px-5 py-2.5 rounded-full shadow-2xl flex items-center gap-3 hidden transition-all z-50">
        <div class="w-3 h-3 border-2 border-white/30 border-t-white rounded-full animate-spin"></div><span id="statusText" class="text-xs font-medium">Processing...</span>
    </div>
    
    <div id="dragOverlay" class="fixed inset-0 bg-neutral-900/5 backdrop-blur-sm z-50 pointer-events-none opacity-0 flex items-center justify-center transition-opacity duration-200">
        <div class="drop-overlay-card px-10 py-8 flex flex-col items-center gap-4">
            <div class="p-4 bg-blue-50 text-blue-500 rounded-2xl"><i class="ph-fill ph-upload-simple text-3xl"></i></div>
            <p class="text-lg font-semibold text-neutral-700">Drop images to import</p>
        </div>
    </div>

    <script>
        // --- SUPABASE CONFIG ---
        const SUPABASE_URL = 'https://uauqqdaalnddedgjdgcg.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InVhdXFxZGFhbG5kZGVkZ2pkZ2NnIiwicm9sZSI6ImFub24iLCJpYXQiOjE3Njc3OTQ2NDIsImV4cCI6MjA4MzM3MDY0Mn0.afUxr9uKdSamnbFQmOt7DDRvEJYLEz3-c8u5P3zZcnE';
        const db = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

        // --- STATE ---
        let appData = { cards: [], folders: [] };
        let deletedCardsStack = [], undoTimeout = null, dragSrcId = null, dragSrcTags = null;
        let collectionId = null;
        let deletionTimers = new Map(); // Track scheduled deletions

        const INBOX_ID = 'inbox';
        const DELETION_GRACE_PERIOD = 15 * 60 * 1000; // 15 minutes in milliseconds

        // --- INIT ---
        window.addEventListener('DOMContentLoaded', async () => {
            await initCollection();
            setupGlobalDrag();
            initScrollBehavior();
            cleanupOldDeletedCards(); // Clean up any cards past grace period

            // Prefs (local only)
            const w = localStorage.getItem('ssaved_width');
            if (w) { document.getElementById('widthSlider').value = w; updateWidth(w); }
            setMobileCols(localStorage.getItem('ssaved_cols') || 1);
        });

        // --- DELETION MANAGEMENT ---
        function schedulePermamentDeletion(cardId, deletedAt) {
            const deletionTime = new Date(deletedAt).getTime() + DELETION_GRACE_PERIOD;
            const now = Date.now();
            const delay = deletionTime - now;

            if (delay <= 0) {
                // Already past grace period, delete immediately
                permanentlyDeleteCard(cardId);
            } else {
                // Schedule deletion
                const timerId = setTimeout(() => {
                    permanentlyDeleteCard(cardId);
                    deletionTimers.delete(cardId);
                }, delay);
                deletionTimers.set(cardId, timerId);
            }
        }

        function cancelPermanentDeletion(cardId) {
            if (deletionTimers.has(cardId)) {
                clearTimeout(deletionTimers.get(cardId));
                deletionTimers.delete(cardId);
            }
        }

        async function permanentlyDeleteCard(cardId) {
            console.log('Permanently deleting card:', cardId);
            // Get the card to find its image path
            const { data: card } = await db
                .from('cards')
                .select('image_path')
                .eq('id', cardId)
                .single();

            if (card?.image_path) {
                // Delete image from storage
                await db.storage.from('images').remove([card.image_path]);
            }

            // Delete card record from database
            await db.from('cards').delete().eq('id', cardId);

            // Remove from undo stack if present
            deletedCardsStack = deletedCardsStack.filter(c => c.id !== cardId);
            updateUndoUI();
        }

        async function cleanupOldDeletedCards() {
            // Find all cards with deleted_at timestamp older than grace period
            const cutoffTime = new Date(Date.now() - DELETION_GRACE_PERIOD).toISOString();

            const { data: oldDeletedCards } = await db
                .from('cards')
                .select('id, deleted_at, image_path')
                .eq('collection_id', collectionId)
                .not('deleted_at', 'is', null)
                .lt('deleted_at', cutoffTime);

            if (oldDeletedCards && oldDeletedCards.length > 0) {
                console.log(`Cleaning up ${oldDeletedCards.length} old deleted cards`);

                for (const card of oldDeletedCards) {
                    // Delete image from storage
                    if (card.image_path) {
                        await db.storage.from('images').remove([card.image_path]);
                    }
                    // Delete card record
                    await db.from('cards').delete().eq('id', card.id);
                }
            }

            // Schedule deletion for recently deleted cards still within grace period
            const { data: recentlyDeletedCards } = await db
                .from('cards')
                .select('id, deleted_at')
                .eq('collection_id', collectionId)
                .not('deleted_at', 'is', null)
                .gte('deleted_at', cutoffTime);

            if (recentlyDeletedCards && recentlyDeletedCards.length > 0) {
                recentlyDeletedCards.forEach(card => {
                    schedulePermamentDeletion(card.id, card.deleted_at);
                });
            }
        }

        // --- COLLECTION MANAGEMENT ---
        async function initCollection() {
            try {
                // Check URL for collection ID
                const urlParams = new URLSearchParams(window.location.search);
                let id = urlParams.get('c');
                
                if (id) {
                    // Try to load existing collection
                    collectionId = id;
                    const exists = await loadCollection(id);
                    if (!exists) {
                        // Collection doesn't exist, create it
                        await createCollection(id);
                    }
                } else {
                    // No ID in URL - check localStorage for existing collection
                    id = localStorage.getItem('ssaved_collection_id');
                    if (id) {
                        collectionId = id;
                        const exists = await loadCollection(id);
                        if (!exists) {
                            // Stored ID is invalid, create new
                            await createNewCollection();
                        }
                    } else {
                        // First time user - create new collection
                        await createNewCollection();
                    }
                }
                
                // Update URL without reload
                updateUrl();
                hideLoading();
            } catch (error) {
                console.error('Init error:', error);
                setLoadingText('Error: ' + error.message);
            }
        }

        function generateCollectionId() {
            // Generate a random 12-character alphanumeric ID
            const chars = 'abcdefghijklmnopqrstuvwxyz0123456789';
            let id = '';
            for (let i = 0; i < 12; i++) {
                id += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return id;
        }

        async function createNewCollection() {
            collectionId = generateCollectionId();
            await createCollection(collectionId);
            localStorage.setItem('ssaved_collection_id', collectionId);
        }

        async function createCollection(id) {
            // Create collection record
            await db.from('collections').insert({ id });
            
            // Create default Inbox folder
            const inboxFolder = { id: INBOX_ID, collection_id: id, name: 'Inbox', order: 0, is_collapsed: false };
            await db.from('folders').insert(inboxFolder);
            
            appData.folders = [{ id: INBOX_ID, name: 'Inbox', order: 0, isCollapsed: false }];
            appData.cards = [];
            render();
        }

        async function loadCollection(id) {
            setLoadingText('Loading your collection...');
            
            // Check if collection exists
            const { data: collection } = await db
                .from('collections')
                .select('id')
                .eq('id', id)
                .single();
            
            if (!collection) return false;
            
            // Load folders
            const { data: folders } = await db
                .from('folders')
                .select('*')
                .eq('collection_id', id)
                .order('order');
            
            appData.folders = (folders || []).map(f => ({
                id: f.id,
                name: f.name,
                order: f.order,
                isCollapsed: f.is_collapsed
            }));
            
            // Ensure Inbox exists
            if (!appData.folders.find(f => f.id === INBOX_ID)) {
                const inboxFolder = { id: INBOX_ID, collection_id: id, name: 'Inbox', order: 0, is_collapsed: false };
                await db.from('folders').insert(inboxFolder);
                appData.folders.unshift({ id: INBOX_ID, name: 'Inbox', order: 0, isCollapsed: false });
            }
            
            // Load cards
            const { data: cards } = await db
                .from('cards')
                .select('*')
                .eq('collection_id', id)
                .order('order');
            
            appData.cards = (cards || [])
                .filter(c => !c.deleted_at) // Filter out soft-deleted cards
                .map(c => ({
                    id: c.id,
                    username: c.username || '',
                    notes: c.notes || '',
                    link: c.link || '#',
                    imageUrl: getPublicImageUrl(c.image_path),
                    imagePath: c.image_path,
                    tags: c.tags || (c.folder_id ? [c.folder_id] : [INBOX_ID]), // Support both old and new format
                    order: c.order,
                    suggestions: c.suggestions || [],
                    isScanning: false,
                    deletedAt: c.deleted_at || null
                }));
            
            render();
            return true;
        }

        function updateUrl() {
            const url = new URL(window.location);
            url.searchParams.set('c', collectionId);
            window.history.replaceState({}, '', url);
        }

        function getPublicImageUrl(path) {
            if (!path) return '';
            return `${SUPABASE_URL}/storage/v1/object/public/images/${path}`;
        }

        function setLoadingText(text) {
            document.getElementById('loadingText').textContent = text;
        }

        function hideLoading() {
            document.getElementById('loadingScreen').classList.add('hidden');
        }

        // --- SCROLL BEHAVIOR ---
        function initScrollBehavior() {
            const header = document.getElementById('mainHeader');
            let lastScrollY = window.scrollY;
            window.addEventListener('scroll', () => {
                const currentScrollY = window.scrollY;
                if (currentScrollY < 0) return;
                if (Math.abs(currentScrollY - lastScrollY) < 10) return;
                if (currentScrollY > lastScrollY && currentScrollY > 60) header.classList.add('-translate-y-full');
                else header.classList.remove('-translate-y-full');
                lastScrollY = currentScrollY;
            }, { passive: true });
        }

        // --- DATABASE OPERATIONS ---
        async function saveCardToDB(card) {
            const dbCard = {
                id: card.id,
                collection_id: collectionId,
                username: card.username,
                notes: card.notes,
                link: card.link,
                image_path: card.imagePath,
                folder_id: card.tags && card.tags.length > 0 ? card.tags[0] : INBOX_ID, // Keep for backwards compat
                tags: card.tags || [INBOX_ID], // New tags array
                order: card.order,
                suggestions: card.suggestions,
                deleted_at: card.deletedAt || null // Soft delete timestamp
            };
            console.log('Saving card to DB:', dbCard);
            const { error } = await db.from('cards').upsert(dbCard);
            if (error) {
                console.error('Card save error:', error);
            }
            showSaved();
            return { error };
        }

        async function saveFolderToDB(folder) {
            const dbFolder = {
                id: folder.id,
                collection_id: collectionId,
                name: folder.name,
                order: folder.order,
                is_collapsed: folder.isCollapsed
            };
            await db.from('folders').upsert(dbFolder);
        }

        async function deleteCardFromDB(id) {
            // Get the card to find its image path
            const card = appData.cards.find(c => c.id === id);
            if (card?.imagePath) {
                // Delete image from storage
                await db.storage.from('images').remove([card.imagePath]);
            }
            // Delete card record
            await db.from('cards').delete().eq('id', id);
        }

        async function deleteFolderFromDB(id) {
            await db.from('folders').delete().eq('id', id);
        }

        function reindexCards(folderId) {
            const subset = appData.cards.filter(c => c.tags && c.tags.includes(folderId)).sort((a,b) => a.order - b.order);
            subset.forEach((c, i) => { c.order = i; saveCardToDB(c); });
        }

        // --- RENDER ---
        function render(restoreId = null) {
            const wrapper = document.getElementById('folderWrapper');
            const empty = document.getElementById('emptyState');
            const rIds = Array.isArray(restoreId) ? restoreId : (restoreId ? [restoreId] : []);

            const hasCards = appData.cards.length > 0;
            const hasCustomFolders = appData.folders.length > 1;

            if (!hasCards && !hasCustomFolders) { 
                empty.classList.remove('hidden'); wrapper.innerHTML = ''; return; 
            }
            empty.classList.add('hidden');
            wrapper.innerHTML = '';

            const mCols = localStorage.getItem('ssaved_cols') || 1;
            const gridClass = `grid-cols-${mCols} md:grid-cols-2 lg:grid-cols-3`;

            appData.folders.forEach(folder => {
                // Cards can have multiple tags, so they can appear in multiple folders
                const fCards = appData.cards.filter(c => c.tags && c.tags.includes(folder.id)).sort((a,b) => a.order - b.order);
                const cardsHtml = fCards.map(c => generateCardHTML(c, rIds)).join('');
                const chevron = folder.isCollapsed ? 'ph-caret-right' : 'ph-caret-down';
                const gridState = folder.isCollapsed ? 'hidden' : '';
                const opacity = folder.isCollapsed ? 'opacity-50' : 'opacity-100';

                const deleteBtn = folder.id === INBOX_ID ? '' : `
                <button onclick="event.stopPropagation(); deleteFolder('${folder.id}')" 
                        class="ml-auto mr-4 p-1.5 text-neutral-300 hover:text-red-500 transition-colors rounded-md opacity-0 group-hover/folder:opacity-100"
                        title="Delete Folder">
                    <i class="ph-bold ph-x text-sm"></i>
                </button>`;

                const section = `
                <section id="folder-${folder.id}" class="folder-enter group/folder">
                    <div class="mb-5 flex items-end relative pl-1 cursor-pointer"
                         onclick="toggleFolder('${folder.id}')"
                         ondragover="handleFolderDragOver(event, '${folder.id}')"
                         ondragleave="handleFolderDragLeave(event, '${folder.id}')"
                         ondrop="handleFolderDrop(event, '${folder.id}')">
                         
                        <div class="folder-tab bg-neutral-200/80 text-neutral-500 py-1.5 text-xs font-semibold uppercase tracking-wider rounded-t-lg transition-all duration-200 select-none group-hover/folder:bg-neutral-300/80 group-hover/folder:text-neutral-600 flex items-center gap-2 ${opacity}">
                            <i class="ph-bold ${chevron} text-xs"></i>
                            ${folder.name} 
                            <span class="opacity-50 font-normal">${fCards.length}</span>
                        </div>
                        
                        ${deleteBtn}
                        <div class="h-px bg-neutral-200/60 w-full mb-px absolute bottom-0 left-0 right-0 -z-10"></div>
                    </div>

                    <div class="folder-grid-area grid ${gridClass} gap-5 md:gap-6 min-h-[50px] transition-all duration-300 ${gridState}"
                         ondragover="handleFolderDragOver(event, '${folder.id}')"
                         ondragleave="handleFolderDragLeave(event, '${folder.id}')"
                         ondrop="handleFolderDrop(event, '${folder.id}')">
                        ${cardsHtml}
                    </div>
                </section>`;
                wrapper.insertAdjacentHTML('beforeend', section);
            });

            requestAnimationFrame(() => {
                initAllNotesCollapsible();
            });
        }

        function generateCardHTML(c, rIds) {
            const isRestored = c.isRestored ? "is-restored" : "";
            const restoreAttr = c.isRestored ? `onmouseenter="clearRestoreStatus(${c.id})"` : "";
            const pulse = c.isScanning ? "animate-pulse-subtle" : "";
            const enter = rIds.includes(c.id) ? 'animate-restore' : '';
            
            const hasSuggestions = !c.isScanning && c.suggestions && c.suggestions.length !== 1;
            let tooltip = "";
            if (hasSuggestions) {
                const content = c.suggestions.length === 0 
                    ? `<div class="bg-white/95 backdrop-blur-md rounded-xl p-3 shadow-xl border border-neutral-100 text-xs text-neutral-500 text-center">No valid text found.</div>`
                    : `<div class="bg-white/95 backdrop-blur-md rounded-xl p-3 shadow-xl border border-neutral-100"><div class="flex flex-wrap gap-2">${c.suggestions.map(w => `<button onmousedown="event.preventDefault(); applySuggestion(${c.id}, '${cleanString(w)}')" class="px-2.5 py-1.5 bg-neutral-50 hover:bg-neutral-100 border border-neutral-200 text-neutral-600 text-xs font-medium rounded-lg transition-all">${w}</button>`).join('')}</div></div>`;
                tooltip = `<div id="tooltip-${c.id}" class="tooltip-container absolute bottom-full left-0 w-full mb-3 z-50"><div class="tooltip-arrow relative">${content}</div></div>`;
            }

            return `
            <div id="card-${c.id}" draggable="true" 
                 ondragstart="handleDragStart(event, ${c.id})" 
                 ondragover="handleCardDragOver(event, ${c.id})" 
                 ondrop="handleCardDrop(event, ${c.id})" 
                 ondragend="handleDragEnd(event)" 
                 ${restoreAttr} 
                 style="view-transition-name: card-${c.id}" 
                 class="card group flex flex-col ${isRestored} ${pulse} ${enter}">
                
                <div class="aspect-[9/16] bg-neutral-100 relative overflow-hidden group/image shrink-0 cursor-pointer" onclick="handleImageClick(event, ${c.id})">
                    <img src="${c.imageUrl}" class="w-full h-full object-cover object-top pointer-events-none transition-transform duration-500 img-hover-scale" loading="lazy">
                    
                    <button onclick="event.stopPropagation(); openProfile(${c.id})" class="external-link-btn p-2 bg-white/80 hover:bg-white backdrop-blur-md border border-white/50 text-neutral-600 hover:text-neutral-900 rounded-lg shadow-lg transition-all">
                        <i class="ph-bold ph-arrow-up-right text-base"></i>
                    </button>
                    
                    <button onclick="event.stopPropagation(); deleteCard(${c.id})" class="delete-btn p-2 bg-white/80 hover:bg-red-50 backdrop-blur-md border border-white/50 text-neutral-600 hover:text-red-500 rounded-lg shadow-lg transition-all">
                        <i class="ph-bold ph-x text-base"></i>
                    </button>
                </div>

                <div class="p-4 flex flex-col gap-3 flex-1">
                    <div class="relative username-wrapper z-10">
                        ${tooltip}
                        <div class="relative group/input">
                            <div class="absolute inset-y-0 left-0 pl-1 flex items-center pointer-events-none"><span class="text-neutral-300 font-medium">@</span></div>
                            <textarea 
                                oninput="autoResize(this); updateCard(${c.id}, 'username', this.value)" 
                                onfocus="autoResize(this); ${hasSuggestions ? `triggerTooltip(${c.id})` : ''}"
                                class="auto-grow w-full pl-6 pr-8 py-1 bg-transparent border-0 border-b border-neutral-100 focus:border-neutral-300 outline-none text-sm font-semibold text-neutral-400 group-hover/input:text-neutral-700 focus:text-neutral-900 transition-colors placeholder:text-neutral-300" 
                                placeholder="Username" rows="1">${c.username}</textarea>
                            ${hasSuggestions ? `<div class="absolute inset-y-0 right-0 pr-2 flex items-center pointer-events-none"><i class="ph-fill ph-magic-wand text-neutral-300 text-sm"></i></div>` : ''}
                        </div>
                    </div>
                    <div class="notes-wrapper" id="notes-wrapper-${c.id}">
                        <div class="notes-fade"></div>
                        <textarea 
                            oninput="autoResize(this); updateCard(${c.id}, 'notes', this.value); checkNotesCollapsible(${c.id})" 
                            onfocus="autoResize(this)"
                            class="notes-textarea auto-grow w-full text-xs text-neutral-500 bg-transparent border-0 border-b border-neutral-50 focus:border-neutral-200 outline-none resize-none p-1 placeholder:text-neutral-300" 
                            rows="1" placeholder="Add notes...">${c.notes}</textarea>
                        <button class="notes-toggle" onclick="toggleNotes(${c.id})" aria-label="Expand notes">
                            <i class="ph-bold ph-caret-down"></i>
                        </button>
                    </div>
                </div>
            </div>`;
        }

        // --- JS UTILS FOR AUTO-GROW ---
        function autoResize(el) {
            el.style.height = 'auto'; 
            el.style.height = el.scrollHeight + 'px';
        }

        // --- COLLAPSIBLE NOTES (Mobile) ---
        const LINE_HEIGHT = 18;
        const MAX_LINES = 3;
        const DWELL_DELAY = 1500;
        let dwellTimers = new Map();
        let notesObserver = null;

        function checkNotesCollapsible(id) {
            if (window.innerWidth >= 768) return;
            
            const wrapper = document.getElementById(`notes-wrapper-${id}`);
            const textarea = wrapper?.querySelector('.notes-textarea');
            if (!wrapper || !textarea) return;

            wrapper.classList.remove('is-collapsible', 'is-expanded');
            textarea.style.maxHeight = 'none';
            
            const fullHeight = textarea.scrollHeight;
            const threshold = LINE_HEIGHT * MAX_LINES;
            
            if (fullHeight > threshold) {
                wrapper.classList.add('is-collapsible');
                textarea.style.maxHeight = '';
            } else {
                textarea.style.maxHeight = '';
            }
        }

        function toggleNotes(id) {
            const wrapper = document.getElementById(`notes-wrapper-${id}`);
            if (wrapper?.classList.contains('is-collapsible')) {
                wrapper.classList.toggle('is-expanded');
            }
        }

        function expandNotes(id) {
            const wrapper = document.getElementById(`notes-wrapper-${id}`);
            if (wrapper?.classList.contains('is-collapsible') && !wrapper.classList.contains('is-expanded')) {
                wrapper.classList.add('is-expanded');
            }
        }

        function initNotesObserver() {
            if (window.innerWidth >= 768) return;
            
            if (notesObserver) notesObserver.disconnect();

            notesObserver = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    const card = entry.target;
                    const id = parseInt(card.id.replace('card-', ''));
                    
                    if (entry.isIntersecting && entry.intersectionRatio >= 0.6) {
                        if (!dwellTimers.has(id)) {
                            dwellTimers.set(id, setTimeout(() => {
                                expandNotes(id);
                                dwellTimers.delete(id);
                            }, DWELL_DELAY));
                        }
                    } else {
                        if (dwellTimers.has(id)) {
                            clearTimeout(dwellTimers.get(id));
                            dwellTimers.delete(id);
                        }
                    }
                });
            }, {
                threshold: [0, 0.6],
                rootMargin: '-20% 0px -20% 0px'
            });

            document.querySelectorAll('[id^="card-"]').forEach(card => {
                notesObserver.observe(card);
            });
        }

        function initAllNotesCollapsible() {
            if (window.innerWidth >= 768) return;
            
            document.querySelectorAll('.notes-textarea').forEach(textarea => {
                autoResize(textarea);
            });
            
            appData.cards.forEach(c => {
                checkNotesCollapsible(c.id);
            });
            
            initNotesObserver();
        }

        let lastWasMobile = window.innerWidth < 768;
        window.addEventListener('resize', () => {
            const isMobile = window.innerWidth < 768;
            if (isMobile !== lastWasMobile) {
                lastWasMobile = isMobile;
                if (isMobile) {
                    initAllNotesCollapsible();
                } else {
                    document.querySelectorAll('.notes-wrapper').forEach(w => {
                        w.classList.remove('is-collapsible', 'is-expanded');
                    });
                    if (notesObserver) notesObserver.disconnect();
                }
            }
        });

        // --- DRAG & DROP ---
        function handleDragStart(e, id) {
            dragSrcId = id;
            const c = appData.cards.find(x => x.id === id);
            dragSrcTags = c ? [...(c.tags || [INBOX_ID])] : null;

            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', id);

            // Create a cleaner drag image by hiding buttons temporarily
            const card = document.getElementById(`card-${id}`);
            if (card) {
                // Hide interactive elements that shouldn't show in drag preview
                const buttons = card.querySelectorAll('button, .external-link-btn, .delete-btn');
                buttons.forEach(btn => btn.style.opacity = '0');

                // Use the card itself as drag image with proper offset
                try {
                    e.dataTransfer.setDragImage(card, card.offsetWidth / 2, 50);
                } catch(err) {
                    // Fallback if setDragImage fails
                    console.log('Drag image failed:', err);
                }

                // Restore buttons after a brief delay
                setTimeout(() => {
                    buttons.forEach(btn => btn.style.opacity = '');
                }, 50);
            }

            document.body.classList.add('global-dragging');
            setTimeout(() => document.getElementById(`card-${id}`)?.classList.add('is-dragging'), 0);
        }

        function handleFolderDragOver(e, folderId) {
            if (!dragSrcId || !dragSrcTags) return;
            e.preventDefault(); e.dataTransfer.dropEffect = 'move';
            document.getElementById(`folder-${folderId}`).classList.add('folder-drop-active');

            const f = appData.folders.find(x => x.id === folderId);
            if(f && f.isCollapsed) { f.isCollapsed = false; saveFolderToDB(f); render(); }
        }

        function handleFolderDragLeave(e, folderId) {
            if (e.relatedTarget && document.getElementById(`folder-${folderId}`).contains(e.relatedTarget)) return;
            document.getElementById(`folder-${folderId}`).classList.remove('folder-drop-active');
        }

        function handleFolderDrop(e, folderId) {
            e.preventDefault();
            document.getElementById(`folder-${folderId}`).classList.remove('folder-drop-active');
            if (dragSrcId && dragSrcTags) {
                const c = appData.cards.find(x => x.id === dragSrcId);
                if (c) {
                    // Add tag if not already present (multi-tag support)
                    if (!c.tags.includes(folderId)) {
                        c.tags.push(folderId);
                        c.order = 0;
                        saveCardToDB(c);
                        reindexCards(folderId);
                        transitionRender();
                    }
                }
            }
        }

        function handleCardDragOver(e, targetId) {
            e.preventDefault(); e.dataTransfer.dropEffect = 'move';
            if (!dragSrcId || dragSrcId === targetId) return;

            const targetCard = appData.cards.find(c => c.id === targetId);
            // Check if cards share at least one common tag
            const commonTags = dragSrcTags.filter(tag => targetCard.tags && targetCard.tags.includes(tag));
            if (commonTags.length === 0) return;

            const folderId = commonTags[0]; // Use first common tag for reordering
            const folderCards = appData.cards.filter(c => c.tags && c.tags.includes(folderId)).sort((a,b) => a.order - b.order);
            const from = folderCards.findIndex(c => c.id === dragSrcId);
            const to = folderCards.findIndex(c => c.id === targetId);

            if (from === -1 || to === -1) return;

            document.querySelectorAll('.card-shift-forward, .card-shift-backward').forEach(el => { 
                el.classList.remove('card-shift-forward', 'card-shift-backward'); 
                el.style.transform = ''; 
            });
            
            const start = Math.min(from, to), end = Math.max(from, to);
            for (let i = start; i <= end; i++) {
                if (i === from) continue;
                const el = document.getElementById(`card-${folderCards[i].id}`);
                if (el) el.classList.add(from < to ? 'card-shift-forward' : 'card-shift-backward');
            }
        }

        function handleCardDrop(e, targetId) {
            e.stopPropagation(); e.preventDefault();
            if (!dragSrcId || dragSrcId === targetId) return;

            const targetCard = appData.cards.find(c => c.id === targetId);
            const commonTags = dragSrcTags.filter(tag => targetCard.tags && targetCard.tags.includes(tag));

            if (commonTags.length > 0) {
                // Reorder within the same folder
                const folderId = commonTags[0];
                const folderCards = appData.cards.filter(c => c.tags && c.tags.includes(folderId)).sort((a,b) => a.order - b.order);
                const from = folderCards.findIndex(c => c.id === dragSrcId);
                const to = folderCards.findIndex(c => c.id === targetId);

                if (from > -1 && to > -1) {
                    const [moved] = folderCards.splice(from, 1);
                    folderCards.splice(to, 0, moved);
                    folderCards.forEach((c, i) => { c.order = i; saveCardToDB(c); });
                    appData.cards.sort((a,b) => a.order - b.order);
                    transitionRender();
                }
            } else {
                // Add tag from target card's first tag
                if (targetCard.tags && targetCard.tags.length > 0) {
                    handleFolderDrop(e, targetCard.tags[0]);
                }
            }
        }

        function handleDragEnd() {
            document.body.classList.remove('global-dragging');
            document.querySelectorAll('.is-dragging, .card-shift-forward, .card-shift-backward, .folder-drop-active').forEach(el => {
                el.classList.remove('is-dragging', 'card-shift-forward', 'card-shift-backward', 'folder-drop-active');
                el.style.transform = '';
            });
            dragSrcId = null; dragSrcTags = null;
        }

        // --- ACTIONS ---
        async function createNewFolder() {
            const name = prompt("Folder Name:");
            if (name) {
                const id = 'folder-' + Date.now();
                const newFolder = { id, name, order: appData.folders.length, isCollapsed: false };
                appData.folders.push(newFolder);
                await saveFolderToDB(newFolder);
                render();
            }
        }
        
        async function toggleFolder(id) {
            const f = appData.folders.find(x => x.id === id);
            if (f) {
                f.isCollapsed = !f.isCollapsed;
                await saveFolderToDB(f);
                render();
            }
        }

        async function deleteFolder(id) {
            if(id === INBOX_ID) return;
            if(!confirm("Delete this folder? Cards will keep their other tags.")) return;

            // Remove this tag from all cards that have it
            const cardsWithTag = appData.cards.filter(c => c.tags && c.tags.includes(id));
            for (const c of cardsWithTag) {
                c.tags = c.tags.filter(tag => tag !== id);
                // If card has no tags left, add it to Inbox
                if (c.tags.length === 0) {
                    c.tags = [INBOX_ID];
                }
                await saveCardToDB(c);
            }

            const idx = appData.folders.findIndex(f => f.id === id);
            if(idx > -1) {
                appData.folders.splice(idx, 1);
                await deleteFolderFromDB(id);
            }
            render();
        }

        // --- FILE & OCR ---
        function simpleCrop(url) {
            return new Promise((resolve) => {
                const img = new Image(); 
                img.crossOrigin = 'anonymous';
                img.onload = () => {
                    const c = document.createElement('canvas'); 
                    const ctx = c.getContext('2d');
                    const h = img.height * 0.2; 
                    c.width = img.width; 
                    c.height = h;
                    ctx.drawImage(img, 0, 0, img.width, h, 0, 0, img.width, h);
                    c.toBlob(resolve);
                }; 
                img.src = url;
            });
        }

        async function handleFiles(files) {
            if (!files.length) return;
            showStatus(true, `Uploading ${files.length} image${files.length > 1 ? 's' : ''}...`);
            
            console.log('Collection ID:', collectionId);
            console.log('Files to upload:', files.length);
            
            const newCards = [];
            
            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                const id = Date.now() + i;
                const imagePath = `${collectionId}/${id}.png`;
                
                console.log('Uploading to path:', imagePath);
                
                // Upload to Supabase Storage
                const { data: uploadData, error: uploadError } = await db.storage
                    .from('images')
                    .upload(imagePath, file, { contentType: file.type });
                
                if (uploadError) {
                    console.error('Upload error:', uploadError);
                    alert('Upload failed: ' + uploadError.message);
                    continue;
                }
                
                console.log('Upload success:', uploadData);
                
                const imageUrl = getPublicImageUrl(imagePath);
                console.log('Image URL:', imageUrl);
                
                const card = {
                    id,
                    username: '',
                    notes: '',
                    link: '#',
                    imageUrl,
                    imagePath,
                    tags: [INBOX_ID],
                    order: 0,
                    suggestions: [],
                    isScanning: true
                };
                
                newCards.push(card);
                
                const { error: dbError } = await saveCardToDB(card);
                if (dbError) {
                    console.error('DB save error:', dbError);
                }
            }
            
            console.log('New cards created:', newCards.length);
            
            if (newCards.length === 0) {
                showStatus(false);
                return;
            }
            
            appData.cards.unshift(...newCards);
            reindexCards(INBOX_ID);
            transitionRender(newCards.map(c => c.id));
            
            showStatus(true, 'Processing OCR...');
            await new Promise(r => setTimeout(r, 100));

            // Run OCR on each new card
            for (const c of newCards) {
                try {
                    const blob = await simpleCrop(c.imageUrl);
                    const { data: { words } } = await Tesseract.recognize(blob, 'eng');
                    const banned = ['follow', 'followers', 'following', 'posts'];
                    const valid = words.map(w => w.text.trim()).filter(w => w.length > 4 && !/[:;,]/.test(w) && !banned.includes(w.toLowerCase())).sort((a,b) => b.length - a.length);
                    const best = valid[0] ? cleanString(valid[0]) : "";
                    
                    const actual = appData.cards.find(x => x.id === c.id);
                    if (actual) {
                        Object.assign(actual, { 
                            username: best, 
                            link: `https://instagram.com/${best}`, 
                            suggestions: valid, 
                            isScanning: false 
                        });
                        await saveCardToDB(actual);
                        
                        const el = document.getElementById(`card-${actual.id}`);
                        if(el) {
                            const txt = el.querySelector('textarea[placeholder="Username"]');
                            if(txt && document.activeElement !== txt) { 
                                txt.value = best; 
                                autoResize(txt); 
                            }
                            el.classList.remove('animate-pulse-subtle');
                        }
                    }
                } catch (e) { 
                    console.error(e); 
                }
            }
            showStatus(false);
        }

        // --- UTILS ---
        function transitionRender(ids) { 
            document.startViewTransition ? document.startViewTransition(() => render(ids)) : render(ids); 
        }
        function showSaved() { 
            const el = document.getElementById('saveIndicator'); 
            el.classList.remove('opacity-0'); 
            setTimeout(() => el.classList.add('opacity-0'), 2000); 
        }
        function showStatus(show, txt) { 
            const el = document.getElementById('statusBar'); 
            el.classList.toggle('hidden', !show); 
            el.classList.toggle('flex', show); 
            if (txt) document.getElementById('statusText').innerText = txt; 
        }
        function cleanString(s) { 
            return s.replace(/[^a-zA-Z0-9_.]/g, '').toLowerCase(); 
        }
        function triggerUpload() { 
            document.getElementById('fileInput').click(); 
        }
        
        function handleImageClick(e, id) { 
            if(!e.target.closest('button')) { 
                // Image click no longer opens link
            }
        }
        
        function openProfile(id) {
            const c = appData.cards.find(x => x.id === id);
            if(c && c.link !== '#') window.open(c.link, '_blank');
        }

        window.addEventListener('click', (e) => { 
            if (!e.target.closest('.username-wrapper')) closeAllTooltips(); 
        });
        window.addEventListener('keydown', (e) => { 
            if (e.key === 'Escape') {
                closeAllTooltips(); 
                closeShareModal();
            }
        });
        
        function triggerTooltip(id) { 
            closeAllTooltips(); 
            document.getElementById(`tooltip-${id}`)?.classList.add('active'); 
        }
        function closeAllTooltips() { 
            document.querySelectorAll('.tooltip-container').forEach(e => e.classList.remove('active')); 
        }
        
        async function applySuggestion(id, w) { 
            const c = appData.cards.find(x => x.id === id); 
            if(c) { 
                c.username = w; 
                c.link = `https://instagram.com/${w}`; 
                await saveCardToDB(c); 
                const el = document.getElementById(`card-${id}`).querySelector('textarea[placeholder="Username"]');
                if(el) { el.value = w; autoResize(el); }
                closeAllTooltips(); 
            } 
        }
        
        async function updateCard(id, f, v) { 
            const c = appData.cards.find(x => x.id === id); 
            if(c) { 
                c[f] = v; 
                if(f === 'username') c.link = `https://instagram.com/${v}`; 
                await saveCardToDB(c); 
            } 
        }

        async function deleteCard(id) {
            const idx = appData.cards.findIndex(c => c.id === id);
            if(idx > -1) {
                const card = appData.cards.splice(idx, 1)[0];

                // Soft delete: set timestamp instead of hard delete
                card.deletedAt = new Date().toISOString();
                await saveCardToDB(card);

                deletedCardsStack.push(card);
                transitionRender();
                updateUndoUI();

                // Schedule permanent deletion after 15 minutes
                schedulePermamentDeletion(id, card.deletedAt);
            }
        }
        
        async function triggerUndo() {
            if (!deletedCardsStack.length) return;
            const c = deletedCardsStack.pop();
            c.isRestored = true;
            c.deletedAt = null; // Clear soft-delete timestamp

            // Cancel scheduled permanent deletion
            cancelPermanentDeletion(c.id);

            // Use first tag for positioning
            const firstTag = c.tags && c.tags.length > 0 ? c.tags[0] : INBOX_ID;
            const folderCards = appData.cards.filter(x => x.tags && x.tags.includes(firstTag)).sort((a,b) => a.order - b.order);
            const insertIdx = Math.min(c.order, folderCards.length);
            folderCards.splice(insertIdx, 0, c);

            folderCards.forEach((card, i) => { card.order = i; saveCardToDB(card); });

            appData.cards = appData.cards.filter(x => x.id !== c.id).concat([c]);

            transitionRender(c.id);
            updateUndoUI();
        }

        function clearRestoreStatus(id) {
            const c = appData.cards.find(x => x.id === id);
            if (c?.isRestored) { 
                c.isRestored = false; 
                saveCardToDB(c); 
                document.getElementById(`card-${id}`)?.classList.remove('is-restored'); 
            }
        }
        
        function updateUndoUI() {
            const btn = document.getElementById('undoBtn'); 
            if(undoTimeout) clearTimeout(undoTimeout);
            if(deletedCardsStack.length) { 
                btn.classList.remove('hidden-btn'); 
                document.getElementById('undoText').innerText = `Undo (${deletedCardsStack.length})`; 
                undoTimeout = setTimeout(() => btn.classList.add('hidden-btn'), 5000); 
            } else {
                btn.classList.add('hidden-btn');
            }
        }

        function setupGlobalDrag() {
            const ov = document.getElementById('dragOverlay'); 
            let c = 0;
            ['dragenter','dragleave','dragover','drop'].forEach(evt => window.addEventListener(evt, e => {
                if (dragSrcId) return; 
                e.preventDefault();
                if (evt === 'dragenter' && e.dataTransfer.types.includes('Files')) { 
                    c++; 
                    ov.classList.remove('opacity-0'); 
                }
                if (evt === 'dragleave') { 
                    c--; 
                    if(c === 0) ov.classList.add('opacity-0'); 
                }
                if (evt === 'drop') { 
                    c = 0; 
                    ov.classList.add('opacity-0'); 
                    if(e.dataTransfer.files.length) handleFiles(e.dataTransfer.files); 
                }
            }));
        }

        function updateWidth(val) { 
            document.getElementById('mainContainer').style.maxWidth = val > 2350 ? '100%' : `${val}px`; 
            localStorage.setItem('ssaved_width', val); 
        }
        
        function setMobileCols(n) {
            localStorage.setItem('ssaved_cols', n);
            [1,2].forEach(i => {
                const btn = document.getElementById(`col-btn-${i}`);
                if(btn) btn.className = `w-8 h-8 flex items-center justify-center rounded-md transition-all ${i==n ? 'bg-white text-neutral-900 shadow-sm font-bold' : 'text-neutral-400'}`;
            });
            render();
        }

        // --- SHARE MODAL ---
        function showShareModal() {
            const modal = document.getElementById('shareModal');
            const input = document.getElementById('shareUrlInput');
            input.value = window.location.href;
            modal.classList.remove('hidden');
            modal.classList.add('flex');
            closeAddMenus();
        }

        function closeShareModal() {
            const modal = document.getElementById('shareModal');
            modal.classList.add('hidden');
            modal.classList.remove('flex');
            document.getElementById('copyConfirm').classList.add('opacity-0');
        }

        function copyShareUrl() {
            const input = document.getElementById('shareUrlInput');
            navigator.clipboard.writeText(input.value);
            document.getElementById('copyConfirm').classList.remove('opacity-0');
            setTimeout(() => {
                document.getElementById('copyConfirm').classList.add('opacity-0');
            }, 2000);
        }

        // --- ADD MENU DROPDOWN ---
        function toggleAddMenu(type) {
            const mobileMenu = document.getElementById('addMenuMobile');
            const desktopMenu = document.getElementById('addMenuDesktop');
            
            if (type === 'mobile') {
                desktopMenu.classList.add('hidden');
                mobileMenu.classList.toggle('hidden');
            } else {
                mobileMenu.classList.add('hidden');
                desktopMenu.classList.toggle('hidden');
            }
        }

        function closeAddMenus() {
            document.getElementById('addMenuMobile')?.classList.add('hidden');
            document.getElementById('addMenuDesktop')?.classList.add('hidden');
        }

        // Close menus when clicking outside
        document.addEventListener('click', (e) => {
            if (!e.target.closest('#addMenuMobile') && !e.target.closest('#addMenuDesktop') && !e.target.closest('[onclick*="toggleAddMenu"]')) {
                closeAddMenus();
            }
        });

        // Close modal on backdrop click
        document.getElementById('shareModal')?.addEventListener('click', (e) => {
            if (e.target.id === 'shareModal') closeShareModal();
        });
    </script>
</body>
</html>
